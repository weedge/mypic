<mxfile host="app.diagrams.net" modified="2021-12-09T08:28:48.964Z" agent="5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36" etag="PASYyEYWiwugL8OeB-Sa" version="15.8.6" type="github">
  <diagram id="FWJPGezK9j8gdbF37r2M" name="Page-1">
    <mxGraphModel dx="1773" dy="603" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="SzUL2O4MbR3VGQP7T_4b-5" value="" style="rounded=1;whiteSpace=wrap;html=1;dashed=1;fontSize=14;fontColor=#7EA6E0;fillColor=none;opacity=50;" vertex="1" parent="1">
          <mxGeometry x="-10" y="526" width="850" height="574" as="geometry" />
        </mxCell>
        <mxCell id="SzUL2O4MbR3VGQP7T_4b-2" value="" style="shape=image;verticalLabelPosition=bottom;labelBackgroundColor=#ffffff;verticalAlign=top;aspect=fixed;imageAspect=0;image=https://www.nginx.com/wp-content/uploads/2016/07/thread-pools-worker-process-event-cycle.png;" vertex="1" parent="1">
          <mxGeometry x="10" y="167.88" width="746.42" height="353.12" as="geometry" />
        </mxCell>
        <mxCell id="SzUL2O4MbR3VGQP7T_4b-3" value="---with-threads配置参数编译，才能使用, worker进程是单线程的(充分利用多核，worker进程数为cpu核数)&lt;br&gt;如果单线程处理的任务存在阻塞影响吞吐，比如磁盘io read,sendfile 大量文件操作时，可以使用aio threads,异步处理&lt;br&gt;根据磁盘数以及硬件开启多个thread_pool 进行专门调优，参数：&lt;br style=&quot;font-size: 14px&quot;&gt;&lt;div style=&quot;font-size: 14px&quot;&gt;# in the &#39;main&#39; context&lt;/div&gt;&lt;div style=&quot;font-size: 14px&quot;&gt;thread_pool default threads=32 max_queue=65536;&lt;/div&gt;&lt;div style=&quot;font-size: 14px&quot;&gt;# in the &#39;http&#39;, &#39;server&#39;, or &#39;location&#39; context&lt;/div&gt;&lt;div style=&quot;font-size: 14px&quot;&gt;aio threads=default;&lt;/div&gt;&lt;div style=&quot;font-size: 14px&quot;&gt;如果max_queue=0,线程池将使用配置中全部数量的线程来尽可能地同时处理多个任务；队列中不会有等待的任务&lt;/div&gt;&lt;div style=&quot;font-size: 14px&quot;&gt;&lt;div style=&quot;font-size: 14px&quot;&gt;如果 max_queue&amp;nbsp;满了，直接报错，而不是放入发送等待队列中等待，&lt;/div&gt;&lt;div style=&quot;font-size: 14px&quot;&gt;这就需要worker进程配置threads加大处理，而不是动态伸缩扩容，可能有性能影响考虑吧&lt;/div&gt;&lt;/div&gt;" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;fontSize=14;fontColor=#5A687D;fontStyle=0" vertex="1" parent="1">
          <mxGeometry x="26.42" y="540" width="730" height="180" as="geometry" />
        </mxCell>
        <mxCell id="SzUL2O4MbR3VGQP7T_4b-4" value="&lt;b style=&quot;font-size: 14px&quot;&gt;&lt;font color=&quot;#7ea6e0&quot;&gt;初始：&lt;br style=&quot;font-size: 14px&quot;&gt;&lt;/font&gt;&lt;/b&gt;读取配置，如果配置中有thread_pool命令，初始化ngx_thread_pool_module模块，完成每个线程池的初始工作，&lt;br style=&quot;font-size: 14px&quot;&gt;ngx_thread_pool_init 初始化一个线程池，初始线程池中的任务队列(单向链表),&lt;br style=&quot;font-size: 14px&quot;&gt;初始互斥锁mutex，初始条件变量cond，根据配置初始多少任务线程，&lt;br style=&quot;font-size: 14px&quot;&gt;&lt;b style=&quot;font-size: 14px&quot;&gt;&lt;font color=&quot;#7ea6e0&quot;&gt;生产：&lt;br style=&quot;font-size: 14px&quot;&gt;&lt;/font&gt;&lt;/b&gt;ngx_thread_task_post&amp;nbsp; 加mutex锁生产任务ngx_thread_task_t 到任务队列队尾，ngx_thread_cond_signal并通知消费任务线程&lt;br style=&quot;font-size: 14px&quot;&gt;&lt;b style=&quot;font-size: 14px&quot;&gt;&lt;font color=&quot;#7ea6e0&quot;&gt;消费：（nginx大法，各种handler，任务task，&lt;/font&gt;&lt;/b&gt;&lt;b&gt;&lt;font color=&quot;#7ea6e0&quot;&gt;事件event，&lt;/font&gt;&lt;/b&gt;&lt;b style=&quot;font-size: 14px&quot;&gt;&lt;font color=&quot;#7ea6e0&quot;&gt;读read/write写）&lt;br style=&quot;font-size: 14px&quot;&gt;&lt;/font&gt;&lt;/b&gt;通过ngx_thread_pool_cycle从任务队列中加mutex锁轮询等待通知，获取任务，执行提交的任务handler函数&lt;br&gt;&lt;b&gt;任务函数&lt;/b&gt;：&lt;br&gt;ngx_thread_read_handler 调用 pread&lt;br&gt;ngx_thread_write_chain_to_file_handler 调用&amp;nbsp;pwritev&lt;br&gt;ngx_linux_sendfile_thread_handler 调用&amp;nbsp;sendfile&lt;br style=&quot;font-size: 14px&quot;&gt;处理完之后，通过ngx_event_actions_t定义的notify通知事件ngx_event_t给ngx_thread_pool_handler进行处理，执行事件hanlder函数&lt;br&gt;&lt;b&gt;事件handler：&lt;br&gt;&lt;/b&gt;ngx_http_cache_thread_event_handler，调用read 之后的&amp;nbsp;write_event_handler 处理相关情况&lt;br&gt;&amp;nbsp;ngx_http_copy_thread_event_handler, &lt;br&gt;ngx_http_upstream_thread_event_handler, 调用sendfile 之后的write_event_handler处理相关情况&amp;nbsp;" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;fontSize=14;fontColor=#5A687D;" vertex="1" parent="1">
          <mxGeometry x="-6" y="740" width="840" height="290" as="geometry" />
        </mxCell>
        <mxCell id="SzUL2O4MbR3VGQP7T_4b-6" value="&lt;font color=&quot;#67ab9f&quot; size=&quot;1&quot;&gt;nginx thread pool&amp;nbsp; event cycle&lt;/font&gt;" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;fontSize=14;fontColor=#7EA6E0;" vertex="1" parent="1">
          <mxGeometry x="520" y="1079" width="170" height="20" as="geometry" />
        </mxCell>
        <mxCell id="SzUL2O4MbR3VGQP7T_4b-7" value="&lt;font color=&quot;#67ab9f&quot; size=&quot;1&quot;&gt;weedge&lt;/font&gt;" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;fontSize=14;fontColor=#7EA6E0;fontStyle=2" vertex="1" parent="1">
          <mxGeometry x="710" y="1079" width="60" height="20" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
